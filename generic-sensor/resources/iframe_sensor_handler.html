<!DOCTYPE html>
<meta charset="utf-8">
<title>iframe sensor tester</title>
<script src="/resources/testharness.js"></script>
<script src="/generic-sensor/resources/generic-sensor-helpers.js"></script>
<script>
  let mockBackend = null;
  let sensor = null;
  let lastTimestamp = null;

  const frequencyInHz = 5;
  const periodInMs = (1 / frequencyInHz) * 1000;

  window.onmessage = (e) => {
    if (e.data.command === 'create_sensor') {
      assert_equals(sensor, null);
      initialize_generic_sensor_tests().then((backend) => {
        mockBackend = backend;
        try {
          sensor = new self[e.data.type]({ frequency: frequencyInHz });
          e.source.postMessage({command: e.data.command,
                                result: 'success'}, '*');
        } catch (error) {
          e.source.postMessage({command: e.data.command, result: error}, '*');
        }
      });
    } else if (e.data.command === 'start_sensor') {
      assert_not_equals(sensor, null);
      try {
        sensor.start();
        sensor.onreading = () => lastTimestamp = sensor.timestamp;
        let onReadingListener = () => {
          e.source.postMessage({command: e.data.command,
                                result: 'success'}, '*');
        }
        sensor.addEventListener('reading', onReadingListener, {once: true});
      } catch (error) {
        e.source.postMessage({command: e.data.command, result: error}, '*');
      }
    } else if (e.data.command === 'is_sensor_suspended') {
      // We have two possibilities here:
      // 1. The sensor is suspended, so there will be no new 'reading' event.
      //    We will call |callback| as a timeout function, with a period larger
      //    enough than the sensor's frequency for us to be sure that at least
      //    one event should have been delivered if the sensor had been active.
      //    The |result| sent as a reply should be true.
      // 2. The sensor is not suspended. In this case, |callback| will be called
      //    as a callback for |sensor|'s "reading" event, and the |result| it
      //    sends back should be false.
      let cachedTimestamp = lastTimestamp;

      const callback = () => {
        // Ensure this function is only called once.
        clearTimeout(timeoutId);
        sensor.removeEventListener('reading', callback);

        e.source.postMessage({
          command: e.data.command,
          result: cachedTimestamp === lastTimestamp
        }, '*');
      };

      const timeoutId = setTimeout(callback, 2 * periodInMs);
      sensor.addEventListener('reading', callback, { once: true });
    } else if (e.data.command === 'reset_sensor_backend') {
      if (sensor) {
        sensor.stop();
      }
      mockBackend.reset().then(() => {
        e.source.postMessage({command: e.data.command,
                              result: 'success'}, '*');
      });
    }
  }
</script>
